/*
NetBox REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.6.1 (3.6)
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netbox

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PluginsAPIService PluginsAPI service
type PluginsAPIService service

type ApiPluginsApplicationsApplicationGroupsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationGroupRequest *[]ApplicationGroupRequest
}

func (r ApiPluginsApplicationsApplicationGroupsBulkDestroyRequest) ApplicationGroupRequest(applicationGroupRequest []ApplicationGroupRequest) ApiPluginsApplicationsApplicationGroupsBulkDestroyRequest {
	r.applicationGroupRequest = &applicationGroupRequest
	return r
}

func (r ApiPluginsApplicationsApplicationGroupsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationGroupsBulkDestroyExecute(r)
}

/*
PluginsApplicationsApplicationGroupsBulkDestroy Method for PluginsApplicationsApplicationGroupsBulkDestroy

Delete a list of application group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationGroupsBulkDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsBulkDestroy(ctx context.Context) ApiPluginsApplicationsApplicationGroupsBulkDestroyRequest {
	return ApiPluginsApplicationsApplicationGroupsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsBulkDestroyExecute(r ApiPluginsApplicationsApplicationGroupsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationGroupsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationGroupRequest == nil {
		return nil, reportError("applicationGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationGroupsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationGroupRequest *[]ApplicationGroupRequest
}

func (r ApiPluginsApplicationsApplicationGroupsBulkPartialUpdateRequest) ApplicationGroupRequest(applicationGroupRequest []ApplicationGroupRequest) ApiPluginsApplicationsApplicationGroupsBulkPartialUpdateRequest {
	r.applicationGroupRequest = &applicationGroupRequest
	return r
}

func (r ApiPluginsApplicationsApplicationGroupsBulkPartialUpdateRequest) Execute() ([]ApplicationGroup, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationGroupsBulkPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationGroupsBulkPartialUpdate Method for PluginsApplicationsApplicationGroupsBulkPartialUpdate

Patch a list of application group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationGroupsBulkPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsBulkPartialUpdate(ctx context.Context) ApiPluginsApplicationsApplicationGroupsBulkPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationGroupsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApplicationGroup
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsBulkPartialUpdateExecute(r ApiPluginsApplicationsApplicationGroupsBulkPartialUpdateRequest) ([]ApplicationGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationGroupsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationGroupRequest == nil {
		return localVarReturnValue, nil, reportError("applicationGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationGroupsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationGroupRequest *[]ApplicationGroupRequest
}

func (r ApiPluginsApplicationsApplicationGroupsBulkUpdateRequest) ApplicationGroupRequest(applicationGroupRequest []ApplicationGroupRequest) ApiPluginsApplicationsApplicationGroupsBulkUpdateRequest {
	r.applicationGroupRequest = &applicationGroupRequest
	return r
}

func (r ApiPluginsApplicationsApplicationGroupsBulkUpdateRequest) Execute() ([]ApplicationGroup, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationGroupsBulkUpdateExecute(r)
}

/*
PluginsApplicationsApplicationGroupsBulkUpdate Method for PluginsApplicationsApplicationGroupsBulkUpdate

Put a list of application group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationGroupsBulkUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsBulkUpdate(ctx context.Context) ApiPluginsApplicationsApplicationGroupsBulkUpdateRequest {
	return ApiPluginsApplicationsApplicationGroupsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApplicationGroup
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsBulkUpdateExecute(r ApiPluginsApplicationsApplicationGroupsBulkUpdateRequest) ([]ApplicationGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationGroupsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationGroupRequest == nil {
		return localVarReturnValue, nil, reportError("applicationGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationGroupsCreateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationGroupRequest *ApplicationGroupRequest
}

func (r ApiPluginsApplicationsApplicationGroupsCreateRequest) ApplicationGroupRequest(applicationGroupRequest ApplicationGroupRequest) ApiPluginsApplicationsApplicationGroupsCreateRequest {
	r.applicationGroupRequest = &applicationGroupRequest
	return r
}

func (r ApiPluginsApplicationsApplicationGroupsCreateRequest) Execute() (*ApplicationGroup, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationGroupsCreateExecute(r)
}

/*
PluginsApplicationsApplicationGroupsCreate Method for PluginsApplicationsApplicationGroupsCreate

Post a list of application group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationGroupsCreateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsCreate(ctx context.Context) ApiPluginsApplicationsApplicationGroupsCreateRequest {
	return ApiPluginsApplicationsApplicationGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApplicationGroup
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsCreateExecute(r ApiPluginsApplicationsApplicationGroupsCreateRequest) (*ApplicationGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationGroupRequest == nil {
		return localVarReturnValue, nil, reportError("applicationGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationGroupsDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationGroupsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationGroupsDestroyExecute(r)
}

/*
PluginsApplicationsApplicationGroupsDestroy Method for PluginsApplicationsApplicationGroupsDestroy

Delete a application group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application group.
 @return ApiPluginsApplicationsApplicationGroupsDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsDestroy(ctx context.Context, id int32) ApiPluginsApplicationsApplicationGroupsDestroyRequest {
	return ApiPluginsApplicationsApplicationGroupsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsDestroyExecute(r ApiPluginsApplicationsApplicationGroupsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationGroupsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationGroupsListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	limit *int32
	offset *int32
	ordering *string
}

// Number of results to return per page.
func (r ApiPluginsApplicationsApplicationGroupsListRequest) Limit(limit int32) ApiPluginsApplicationsApplicationGroupsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPluginsApplicationsApplicationGroupsListRequest) Offset(offset int32) ApiPluginsApplicationsApplicationGroupsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiPluginsApplicationsApplicationGroupsListRequest) Ordering(ordering string) ApiPluginsApplicationsApplicationGroupsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiPluginsApplicationsApplicationGroupsListRequest) Execute() (*PaginatedApplicationGroupList, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationGroupsListExecute(r)
}

/*
PluginsApplicationsApplicationGroupsList Method for PluginsApplicationsApplicationGroupsList

Get a list of application group objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationGroupsListRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsList(ctx context.Context) ApiPluginsApplicationsApplicationGroupsListRequest {
	return ApiPluginsApplicationsApplicationGroupsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedApplicationGroupList
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsListExecute(r ApiPluginsApplicationsApplicationGroupsListRequest) (*PaginatedApplicationGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedApplicationGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-groups/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationGroupsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	patchedApplicationGroupRequest *PatchedApplicationGroupRequest
}

func (r ApiPluginsApplicationsApplicationGroupsPartialUpdateRequest) PatchedApplicationGroupRequest(patchedApplicationGroupRequest PatchedApplicationGroupRequest) ApiPluginsApplicationsApplicationGroupsPartialUpdateRequest {
	r.patchedApplicationGroupRequest = &patchedApplicationGroupRequest
	return r
}

func (r ApiPluginsApplicationsApplicationGroupsPartialUpdateRequest) Execute() (*ApplicationGroup, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationGroupsPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationGroupsPartialUpdate Method for PluginsApplicationsApplicationGroupsPartialUpdate

Patch a application group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application group.
 @return ApiPluginsApplicationsApplicationGroupsPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsPartialUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationGroupsPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationGroupsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationGroup
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsPartialUpdateExecute(r ApiPluginsApplicationsApplicationGroupsPartialUpdateRequest) (*ApplicationGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationGroupsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedApplicationGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationGroupsRetrieveRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationGroupsRetrieveRequest) Execute() (*ApplicationGroup, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationGroupsRetrieveExecute(r)
}

/*
PluginsApplicationsApplicationGroupsRetrieve Method for PluginsApplicationsApplicationGroupsRetrieve

Get a application group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application group.
 @return ApiPluginsApplicationsApplicationGroupsRetrieveRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsRetrieve(ctx context.Context, id int32) ApiPluginsApplicationsApplicationGroupsRetrieveRequest {
	return ApiPluginsApplicationsApplicationGroupsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationGroup
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsRetrieveExecute(r ApiPluginsApplicationsApplicationGroupsRetrieveRequest) (*ApplicationGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationGroupsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationGroupsUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	applicationGroupRequest *ApplicationGroupRequest
}

func (r ApiPluginsApplicationsApplicationGroupsUpdateRequest) ApplicationGroupRequest(applicationGroupRequest ApplicationGroupRequest) ApiPluginsApplicationsApplicationGroupsUpdateRequest {
	r.applicationGroupRequest = &applicationGroupRequest
	return r
}

func (r ApiPluginsApplicationsApplicationGroupsUpdateRequest) Execute() (*ApplicationGroup, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationGroupsUpdateExecute(r)
}

/*
PluginsApplicationsApplicationGroupsUpdate Method for PluginsApplicationsApplicationGroupsUpdate

Put a application group object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application group.
 @return ApiPluginsApplicationsApplicationGroupsUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationGroupsUpdateRequest {
	return ApiPluginsApplicationsApplicationGroupsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationGroup
func (a *PluginsAPIService) PluginsApplicationsApplicationGroupsUpdateExecute(r ApiPluginsApplicationsApplicationGroupsUpdateRequest) (*ApplicationGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationGroupsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-groups/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationGroupRequest == nil {
		return localVarReturnValue, nil, reportError("applicationGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationGroupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationLinksBulkDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationLinkRequest *[]ApplicationLinkRequest
}

func (r ApiPluginsApplicationsApplicationLinksBulkDestroyRequest) ApplicationLinkRequest(applicationLinkRequest []ApplicationLinkRequest) ApiPluginsApplicationsApplicationLinksBulkDestroyRequest {
	r.applicationLinkRequest = &applicationLinkRequest
	return r
}

func (r ApiPluginsApplicationsApplicationLinksBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationLinksBulkDestroyExecute(r)
}

/*
PluginsApplicationsApplicationLinksBulkDestroy Method for PluginsApplicationsApplicationLinksBulkDestroy

Delete a list of application link objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationLinksBulkDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksBulkDestroy(ctx context.Context) ApiPluginsApplicationsApplicationLinksBulkDestroyRequest {
	return ApiPluginsApplicationsApplicationLinksBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksBulkDestroyExecute(r ApiPluginsApplicationsApplicationLinksBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationLinksBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationLinkRequest == nil {
		return nil, reportError("applicationLinkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationLinkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationLinksBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationLinkRequest *[]ApplicationLinkRequest
}

func (r ApiPluginsApplicationsApplicationLinksBulkPartialUpdateRequest) ApplicationLinkRequest(applicationLinkRequest []ApplicationLinkRequest) ApiPluginsApplicationsApplicationLinksBulkPartialUpdateRequest {
	r.applicationLinkRequest = &applicationLinkRequest
	return r
}

func (r ApiPluginsApplicationsApplicationLinksBulkPartialUpdateRequest) Execute() ([]ApplicationLink, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationLinksBulkPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationLinksBulkPartialUpdate Method for PluginsApplicationsApplicationLinksBulkPartialUpdate

Patch a list of application link objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationLinksBulkPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksBulkPartialUpdate(ctx context.Context) ApiPluginsApplicationsApplicationLinksBulkPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationLinksBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApplicationLink
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksBulkPartialUpdateExecute(r ApiPluginsApplicationsApplicationLinksBulkPartialUpdateRequest) ([]ApplicationLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationLinksBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationLinkRequest == nil {
		return localVarReturnValue, nil, reportError("applicationLinkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationLinkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationLinksBulkUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationLinkRequest *[]ApplicationLinkRequest
}

func (r ApiPluginsApplicationsApplicationLinksBulkUpdateRequest) ApplicationLinkRequest(applicationLinkRequest []ApplicationLinkRequest) ApiPluginsApplicationsApplicationLinksBulkUpdateRequest {
	r.applicationLinkRequest = &applicationLinkRequest
	return r
}

func (r ApiPluginsApplicationsApplicationLinksBulkUpdateRequest) Execute() ([]ApplicationLink, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationLinksBulkUpdateExecute(r)
}

/*
PluginsApplicationsApplicationLinksBulkUpdate Method for PluginsApplicationsApplicationLinksBulkUpdate

Put a list of application link objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationLinksBulkUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksBulkUpdate(ctx context.Context) ApiPluginsApplicationsApplicationLinksBulkUpdateRequest {
	return ApiPluginsApplicationsApplicationLinksBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApplicationLink
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksBulkUpdateExecute(r ApiPluginsApplicationsApplicationLinksBulkUpdateRequest) ([]ApplicationLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationLinksBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationLinkRequest == nil {
		return localVarReturnValue, nil, reportError("applicationLinkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationLinkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationLinksCreateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationLinkRequest *ApplicationLinkRequest
}

func (r ApiPluginsApplicationsApplicationLinksCreateRequest) ApplicationLinkRequest(applicationLinkRequest ApplicationLinkRequest) ApiPluginsApplicationsApplicationLinksCreateRequest {
	r.applicationLinkRequest = &applicationLinkRequest
	return r
}

func (r ApiPluginsApplicationsApplicationLinksCreateRequest) Execute() (*ApplicationLink, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationLinksCreateExecute(r)
}

/*
PluginsApplicationsApplicationLinksCreate Method for PluginsApplicationsApplicationLinksCreate

Post a list of application link objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationLinksCreateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksCreate(ctx context.Context) ApiPluginsApplicationsApplicationLinksCreateRequest {
	return ApiPluginsApplicationsApplicationLinksCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApplicationLink
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksCreateExecute(r ApiPluginsApplicationsApplicationLinksCreateRequest) (*ApplicationLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationLinksCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationLinkRequest == nil {
		return localVarReturnValue, nil, reportError("applicationLinkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationLinkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationLinksDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationLinksDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationLinksDestroyExecute(r)
}

/*
PluginsApplicationsApplicationLinksDestroy Method for PluginsApplicationsApplicationLinksDestroy

Delete a application link object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application link.
 @return ApiPluginsApplicationsApplicationLinksDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksDestroy(ctx context.Context, id int32) ApiPluginsApplicationsApplicationLinksDestroyRequest {
	return ApiPluginsApplicationsApplicationLinksDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksDestroyExecute(r ApiPluginsApplicationsApplicationLinksDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationLinksDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationLinksListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	limit *int32
	offset *int32
	ordering *string
}

// Number of results to return per page.
func (r ApiPluginsApplicationsApplicationLinksListRequest) Limit(limit int32) ApiPluginsApplicationsApplicationLinksListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPluginsApplicationsApplicationLinksListRequest) Offset(offset int32) ApiPluginsApplicationsApplicationLinksListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiPluginsApplicationsApplicationLinksListRequest) Ordering(ordering string) ApiPluginsApplicationsApplicationLinksListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiPluginsApplicationsApplicationLinksListRequest) Execute() (*PaginatedApplicationLinkList, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationLinksListExecute(r)
}

/*
PluginsApplicationsApplicationLinksList Method for PluginsApplicationsApplicationLinksList

Get a list of application link objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationLinksListRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksList(ctx context.Context) ApiPluginsApplicationsApplicationLinksListRequest {
	return ApiPluginsApplicationsApplicationLinksListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedApplicationLinkList
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksListExecute(r ApiPluginsApplicationsApplicationLinksListRequest) (*PaginatedApplicationLinkList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedApplicationLinkList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationLinksList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-links/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationLinksPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	patchedApplicationLinkRequest *PatchedApplicationLinkRequest
}

func (r ApiPluginsApplicationsApplicationLinksPartialUpdateRequest) PatchedApplicationLinkRequest(patchedApplicationLinkRequest PatchedApplicationLinkRequest) ApiPluginsApplicationsApplicationLinksPartialUpdateRequest {
	r.patchedApplicationLinkRequest = &patchedApplicationLinkRequest
	return r
}

func (r ApiPluginsApplicationsApplicationLinksPartialUpdateRequest) Execute() (*ApplicationLink, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationLinksPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationLinksPartialUpdate Method for PluginsApplicationsApplicationLinksPartialUpdate

Patch a application link object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application link.
 @return ApiPluginsApplicationsApplicationLinksPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksPartialUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationLinksPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationLinksPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationLink
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksPartialUpdateExecute(r ApiPluginsApplicationsApplicationLinksPartialUpdateRequest) (*ApplicationLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationLinksPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedApplicationLinkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationLinksRetrieveRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationLinksRetrieveRequest) Execute() (*ApplicationLink, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationLinksRetrieveExecute(r)
}

/*
PluginsApplicationsApplicationLinksRetrieve Method for PluginsApplicationsApplicationLinksRetrieve

Get a application link object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application link.
 @return ApiPluginsApplicationsApplicationLinksRetrieveRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksRetrieve(ctx context.Context, id int32) ApiPluginsApplicationsApplicationLinksRetrieveRequest {
	return ApiPluginsApplicationsApplicationLinksRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationLink
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksRetrieveExecute(r ApiPluginsApplicationsApplicationLinksRetrieveRequest) (*ApplicationLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationLinksRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationLinksUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	applicationLinkRequest *ApplicationLinkRequest
}

func (r ApiPluginsApplicationsApplicationLinksUpdateRequest) ApplicationLinkRequest(applicationLinkRequest ApplicationLinkRequest) ApiPluginsApplicationsApplicationLinksUpdateRequest {
	r.applicationLinkRequest = &applicationLinkRequest
	return r
}

func (r ApiPluginsApplicationsApplicationLinksUpdateRequest) Execute() (*ApplicationLink, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationLinksUpdateExecute(r)
}

/*
PluginsApplicationsApplicationLinksUpdate Method for PluginsApplicationsApplicationLinksUpdate

Put a application link object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application link.
 @return ApiPluginsApplicationsApplicationLinksUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationLinksUpdateRequest {
	return ApiPluginsApplicationsApplicationLinksUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationLink
func (a *PluginsAPIService) PluginsApplicationsApplicationLinksUpdateExecute(r ApiPluginsApplicationsApplicationLinksUpdateRequest) (*ApplicationLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationLinksUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-links/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationLinkRequest == nil {
		return localVarReturnValue, nil, reportError("applicationLinkRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationLinkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationPortsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationPortRequest *[]ApplicationPortRequest
}

func (r ApiPluginsApplicationsApplicationPortsBulkDestroyRequest) ApplicationPortRequest(applicationPortRequest []ApplicationPortRequest) ApiPluginsApplicationsApplicationPortsBulkDestroyRequest {
	r.applicationPortRequest = &applicationPortRequest
	return r
}

func (r ApiPluginsApplicationsApplicationPortsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationPortsBulkDestroyExecute(r)
}

/*
PluginsApplicationsApplicationPortsBulkDestroy Method for PluginsApplicationsApplicationPortsBulkDestroy

Delete a list of application port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationPortsBulkDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsBulkDestroy(ctx context.Context) ApiPluginsApplicationsApplicationPortsBulkDestroyRequest {
	return ApiPluginsApplicationsApplicationPortsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsBulkDestroyExecute(r ApiPluginsApplicationsApplicationPortsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationPortsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationPortRequest == nil {
		return nil, reportError("applicationPortRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationPortsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationPortRequest *[]ApplicationPortRequest
}

func (r ApiPluginsApplicationsApplicationPortsBulkPartialUpdateRequest) ApplicationPortRequest(applicationPortRequest []ApplicationPortRequest) ApiPluginsApplicationsApplicationPortsBulkPartialUpdateRequest {
	r.applicationPortRequest = &applicationPortRequest
	return r
}

func (r ApiPluginsApplicationsApplicationPortsBulkPartialUpdateRequest) Execute() ([]ApplicationPort, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationPortsBulkPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationPortsBulkPartialUpdate Method for PluginsApplicationsApplicationPortsBulkPartialUpdate

Patch a list of application port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationPortsBulkPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsBulkPartialUpdate(ctx context.Context) ApiPluginsApplicationsApplicationPortsBulkPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationPortsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApplicationPort
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsBulkPartialUpdateExecute(r ApiPluginsApplicationsApplicationPortsBulkPartialUpdateRequest) ([]ApplicationPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationPortsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationPortRequest == nil {
		return localVarReturnValue, nil, reportError("applicationPortRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationPortsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationPortRequest *[]ApplicationPortRequest
}

func (r ApiPluginsApplicationsApplicationPortsBulkUpdateRequest) ApplicationPortRequest(applicationPortRequest []ApplicationPortRequest) ApiPluginsApplicationsApplicationPortsBulkUpdateRequest {
	r.applicationPortRequest = &applicationPortRequest
	return r
}

func (r ApiPluginsApplicationsApplicationPortsBulkUpdateRequest) Execute() ([]ApplicationPort, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationPortsBulkUpdateExecute(r)
}

/*
PluginsApplicationsApplicationPortsBulkUpdate Method for PluginsApplicationsApplicationPortsBulkUpdate

Put a list of application port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationPortsBulkUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsBulkUpdate(ctx context.Context) ApiPluginsApplicationsApplicationPortsBulkUpdateRequest {
	return ApiPluginsApplicationsApplicationPortsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApplicationPort
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsBulkUpdateExecute(r ApiPluginsApplicationsApplicationPortsBulkUpdateRequest) ([]ApplicationPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationPortsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationPortRequest == nil {
		return localVarReturnValue, nil, reportError("applicationPortRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationPortsCreateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationPortRequest *ApplicationPortRequest
}

func (r ApiPluginsApplicationsApplicationPortsCreateRequest) ApplicationPortRequest(applicationPortRequest ApplicationPortRequest) ApiPluginsApplicationsApplicationPortsCreateRequest {
	r.applicationPortRequest = &applicationPortRequest
	return r
}

func (r ApiPluginsApplicationsApplicationPortsCreateRequest) Execute() (*ApplicationPort, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationPortsCreateExecute(r)
}

/*
PluginsApplicationsApplicationPortsCreate Method for PluginsApplicationsApplicationPortsCreate

Post a list of application port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationPortsCreateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsCreate(ctx context.Context) ApiPluginsApplicationsApplicationPortsCreateRequest {
	return ApiPluginsApplicationsApplicationPortsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApplicationPort
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsCreateExecute(r ApiPluginsApplicationsApplicationPortsCreateRequest) (*ApplicationPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationPortsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationPortRequest == nil {
		return localVarReturnValue, nil, reportError("applicationPortRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationPortsDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationPortsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationPortsDestroyExecute(r)
}

/*
PluginsApplicationsApplicationPortsDestroy Method for PluginsApplicationsApplicationPortsDestroy

Delete a application port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application port.
 @return ApiPluginsApplicationsApplicationPortsDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsDestroy(ctx context.Context, id int32) ApiPluginsApplicationsApplicationPortsDestroyRequest {
	return ApiPluginsApplicationsApplicationPortsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsDestroyExecute(r ApiPluginsApplicationsApplicationPortsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationPortsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationPortsListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	limit *int32
	offset *int32
	ordering *string
}

// Number of results to return per page.
func (r ApiPluginsApplicationsApplicationPortsListRequest) Limit(limit int32) ApiPluginsApplicationsApplicationPortsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPluginsApplicationsApplicationPortsListRequest) Offset(offset int32) ApiPluginsApplicationsApplicationPortsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiPluginsApplicationsApplicationPortsListRequest) Ordering(ordering string) ApiPluginsApplicationsApplicationPortsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiPluginsApplicationsApplicationPortsListRequest) Execute() (*PaginatedApplicationPortList, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationPortsListExecute(r)
}

/*
PluginsApplicationsApplicationPortsList Method for PluginsApplicationsApplicationPortsList

Get a list of application port objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationPortsListRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsList(ctx context.Context) ApiPluginsApplicationsApplicationPortsListRequest {
	return ApiPluginsApplicationsApplicationPortsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedApplicationPortList
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsListExecute(r ApiPluginsApplicationsApplicationPortsListRequest) (*PaginatedApplicationPortList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedApplicationPortList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationPortsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationPortsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	patchedApplicationPortRequest *PatchedApplicationPortRequest
}

func (r ApiPluginsApplicationsApplicationPortsPartialUpdateRequest) PatchedApplicationPortRequest(patchedApplicationPortRequest PatchedApplicationPortRequest) ApiPluginsApplicationsApplicationPortsPartialUpdateRequest {
	r.patchedApplicationPortRequest = &patchedApplicationPortRequest
	return r
}

func (r ApiPluginsApplicationsApplicationPortsPartialUpdateRequest) Execute() (*ApplicationPort, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationPortsPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationPortsPartialUpdate Method for PluginsApplicationsApplicationPortsPartialUpdate

Patch a application port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application port.
 @return ApiPluginsApplicationsApplicationPortsPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsPartialUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationPortsPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationPortsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationPort
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsPartialUpdateExecute(r ApiPluginsApplicationsApplicationPortsPartialUpdateRequest) (*ApplicationPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationPortsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedApplicationPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationPortsRetrieveRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationPortsRetrieveRequest) Execute() (*ApplicationPort, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationPortsRetrieveExecute(r)
}

/*
PluginsApplicationsApplicationPortsRetrieve Method for PluginsApplicationsApplicationPortsRetrieve

Get a application port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application port.
 @return ApiPluginsApplicationsApplicationPortsRetrieveRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsRetrieve(ctx context.Context, id int32) ApiPluginsApplicationsApplicationPortsRetrieveRequest {
	return ApiPluginsApplicationsApplicationPortsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationPort
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsRetrieveExecute(r ApiPluginsApplicationsApplicationPortsRetrieveRequest) (*ApplicationPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationPortsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationPortsUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	applicationPortRequest *ApplicationPortRequest
}

func (r ApiPluginsApplicationsApplicationPortsUpdateRequest) ApplicationPortRequest(applicationPortRequest ApplicationPortRequest) ApiPluginsApplicationsApplicationPortsUpdateRequest {
	r.applicationPortRequest = &applicationPortRequest
	return r
}

func (r ApiPluginsApplicationsApplicationPortsUpdateRequest) Execute() (*ApplicationPort, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationPortsUpdateExecute(r)
}

/*
PluginsApplicationsApplicationPortsUpdate Method for PluginsApplicationsApplicationPortsUpdate

Put a application port object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application port.
 @return ApiPluginsApplicationsApplicationPortsUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationPortsUpdateRequest {
	return ApiPluginsApplicationsApplicationPortsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationPort
func (a *PluginsAPIService) PluginsApplicationsApplicationPortsUpdateExecute(r ApiPluginsApplicationsApplicationPortsUpdateRequest) (*ApplicationPort, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationPort
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationPortsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationPortRequest == nil {
		return localVarReturnValue, nil, reportError("applicationPortRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationPortRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationProtocolsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationProtocolRequest *[]ApplicationProtocolRequest
}

func (r ApiPluginsApplicationsApplicationProtocolsBulkDestroyRequest) ApplicationProtocolRequest(applicationProtocolRequest []ApplicationProtocolRequest) ApiPluginsApplicationsApplicationProtocolsBulkDestroyRequest {
	r.applicationProtocolRequest = &applicationProtocolRequest
	return r
}

func (r ApiPluginsApplicationsApplicationProtocolsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationProtocolsBulkDestroyExecute(r)
}

/*
PluginsApplicationsApplicationProtocolsBulkDestroy Method for PluginsApplicationsApplicationProtocolsBulkDestroy

Delete a list of application protocol objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationProtocolsBulkDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsBulkDestroy(ctx context.Context) ApiPluginsApplicationsApplicationProtocolsBulkDestroyRequest {
	return ApiPluginsApplicationsApplicationProtocolsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsBulkDestroyExecute(r ApiPluginsApplicationsApplicationProtocolsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationProtocolsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-protocols/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationProtocolRequest == nil {
		return nil, reportError("applicationProtocolRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationProtocolRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationProtocolsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationProtocolRequest *[]ApplicationProtocolRequest
}

func (r ApiPluginsApplicationsApplicationProtocolsBulkPartialUpdateRequest) ApplicationProtocolRequest(applicationProtocolRequest []ApplicationProtocolRequest) ApiPluginsApplicationsApplicationProtocolsBulkPartialUpdateRequest {
	r.applicationProtocolRequest = &applicationProtocolRequest
	return r
}

func (r ApiPluginsApplicationsApplicationProtocolsBulkPartialUpdateRequest) Execute() ([]ApplicationProtocol, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationProtocolsBulkPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationProtocolsBulkPartialUpdate Method for PluginsApplicationsApplicationProtocolsBulkPartialUpdate

Patch a list of application protocol objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationProtocolsBulkPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsBulkPartialUpdate(ctx context.Context) ApiPluginsApplicationsApplicationProtocolsBulkPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationProtocolsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApplicationProtocol
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsBulkPartialUpdateExecute(r ApiPluginsApplicationsApplicationProtocolsBulkPartialUpdateRequest) ([]ApplicationProtocol, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationProtocol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationProtocolsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-protocols/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationProtocolRequest == nil {
		return localVarReturnValue, nil, reportError("applicationProtocolRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationProtocolRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationProtocolsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationProtocolRequest *[]ApplicationProtocolRequest
}

func (r ApiPluginsApplicationsApplicationProtocolsBulkUpdateRequest) ApplicationProtocolRequest(applicationProtocolRequest []ApplicationProtocolRequest) ApiPluginsApplicationsApplicationProtocolsBulkUpdateRequest {
	r.applicationProtocolRequest = &applicationProtocolRequest
	return r
}

func (r ApiPluginsApplicationsApplicationProtocolsBulkUpdateRequest) Execute() ([]ApplicationProtocol, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationProtocolsBulkUpdateExecute(r)
}

/*
PluginsApplicationsApplicationProtocolsBulkUpdate Method for PluginsApplicationsApplicationProtocolsBulkUpdate

Put a list of application protocol objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationProtocolsBulkUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsBulkUpdate(ctx context.Context) ApiPluginsApplicationsApplicationProtocolsBulkUpdateRequest {
	return ApiPluginsApplicationsApplicationProtocolsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ApplicationProtocol
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsBulkUpdateExecute(r ApiPluginsApplicationsApplicationProtocolsBulkUpdateRequest) ([]ApplicationProtocol, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApplicationProtocol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationProtocolsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-protocols/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationProtocolRequest == nil {
		return localVarReturnValue, nil, reportError("applicationProtocolRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationProtocolRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationProtocolsCreateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationProtocolRequest *ApplicationProtocolRequest
}

func (r ApiPluginsApplicationsApplicationProtocolsCreateRequest) ApplicationProtocolRequest(applicationProtocolRequest ApplicationProtocolRequest) ApiPluginsApplicationsApplicationProtocolsCreateRequest {
	r.applicationProtocolRequest = &applicationProtocolRequest
	return r
}

func (r ApiPluginsApplicationsApplicationProtocolsCreateRequest) Execute() (*ApplicationProtocol, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationProtocolsCreateExecute(r)
}

/*
PluginsApplicationsApplicationProtocolsCreate Method for PluginsApplicationsApplicationProtocolsCreate

Post a list of application protocol objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationProtocolsCreateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsCreate(ctx context.Context) ApiPluginsApplicationsApplicationProtocolsCreateRequest {
	return ApiPluginsApplicationsApplicationProtocolsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApplicationProtocol
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsCreateExecute(r ApiPluginsApplicationsApplicationProtocolsCreateRequest) (*ApplicationProtocol, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationProtocol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationProtocolsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-protocols/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationProtocolRequest == nil {
		return localVarReturnValue, nil, reportError("applicationProtocolRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationProtocolRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationProtocolsDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationProtocolsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationProtocolsDestroyExecute(r)
}

/*
PluginsApplicationsApplicationProtocolsDestroy Method for PluginsApplicationsApplicationProtocolsDestroy

Delete a application protocol object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application protocol.
 @return ApiPluginsApplicationsApplicationProtocolsDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsDestroy(ctx context.Context, id int32) ApiPluginsApplicationsApplicationProtocolsDestroyRequest {
	return ApiPluginsApplicationsApplicationProtocolsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsDestroyExecute(r ApiPluginsApplicationsApplicationProtocolsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationProtocolsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-protocols/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationProtocolsListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	limit *int32
	offset *int32
	ordering *string
}

// Number of results to return per page.
func (r ApiPluginsApplicationsApplicationProtocolsListRequest) Limit(limit int32) ApiPluginsApplicationsApplicationProtocolsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPluginsApplicationsApplicationProtocolsListRequest) Offset(offset int32) ApiPluginsApplicationsApplicationProtocolsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiPluginsApplicationsApplicationProtocolsListRequest) Ordering(ordering string) ApiPluginsApplicationsApplicationProtocolsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiPluginsApplicationsApplicationProtocolsListRequest) Execute() (*PaginatedApplicationProtocolList, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationProtocolsListExecute(r)
}

/*
PluginsApplicationsApplicationProtocolsList Method for PluginsApplicationsApplicationProtocolsList

Get a list of application protocol objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationProtocolsListRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsList(ctx context.Context) ApiPluginsApplicationsApplicationProtocolsListRequest {
	return ApiPluginsApplicationsApplicationProtocolsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedApplicationProtocolList
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsListExecute(r ApiPluginsApplicationsApplicationProtocolsListRequest) (*PaginatedApplicationProtocolList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedApplicationProtocolList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationProtocolsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-protocols/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationProtocolsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	patchedApplicationProtocolRequest *PatchedApplicationProtocolRequest
}

func (r ApiPluginsApplicationsApplicationProtocolsPartialUpdateRequest) PatchedApplicationProtocolRequest(patchedApplicationProtocolRequest PatchedApplicationProtocolRequest) ApiPluginsApplicationsApplicationProtocolsPartialUpdateRequest {
	r.patchedApplicationProtocolRequest = &patchedApplicationProtocolRequest
	return r
}

func (r ApiPluginsApplicationsApplicationProtocolsPartialUpdateRequest) Execute() (*ApplicationProtocol, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationProtocolsPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationProtocolsPartialUpdate Method for PluginsApplicationsApplicationProtocolsPartialUpdate

Patch a application protocol object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application protocol.
 @return ApiPluginsApplicationsApplicationProtocolsPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsPartialUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationProtocolsPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationProtocolsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationProtocol
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsPartialUpdateExecute(r ApiPluginsApplicationsApplicationProtocolsPartialUpdateRequest) (*ApplicationProtocol, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationProtocol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationProtocolsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-protocols/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedApplicationProtocolRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationProtocolsRetrieveRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationProtocolsRetrieveRequest) Execute() (*ApplicationProtocol, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationProtocolsRetrieveExecute(r)
}

/*
PluginsApplicationsApplicationProtocolsRetrieve Method for PluginsApplicationsApplicationProtocolsRetrieve

Get a application protocol object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application protocol.
 @return ApiPluginsApplicationsApplicationProtocolsRetrieveRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsRetrieve(ctx context.Context, id int32) ApiPluginsApplicationsApplicationProtocolsRetrieveRequest {
	return ApiPluginsApplicationsApplicationProtocolsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationProtocol
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsRetrieveExecute(r ApiPluginsApplicationsApplicationProtocolsRetrieveRequest) (*ApplicationProtocol, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationProtocol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationProtocolsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-protocols/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationProtocolsUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	applicationProtocolRequest *ApplicationProtocolRequest
}

func (r ApiPluginsApplicationsApplicationProtocolsUpdateRequest) ApplicationProtocolRequest(applicationProtocolRequest ApplicationProtocolRequest) ApiPluginsApplicationsApplicationProtocolsUpdateRequest {
	r.applicationProtocolRequest = &applicationProtocolRequest
	return r
}

func (r ApiPluginsApplicationsApplicationProtocolsUpdateRequest) Execute() (*ApplicationProtocol, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationProtocolsUpdateExecute(r)
}

/*
PluginsApplicationsApplicationProtocolsUpdate Method for PluginsApplicationsApplicationProtocolsUpdate

Put a application protocol object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application protocol.
 @return ApiPluginsApplicationsApplicationProtocolsUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationProtocolsUpdateRequest {
	return ApiPluginsApplicationsApplicationProtocolsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ApplicationProtocol
func (a *PluginsAPIService) PluginsApplicationsApplicationProtocolsUpdateExecute(r ApiPluginsApplicationsApplicationProtocolsUpdateRequest) (*ApplicationProtocol, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicationProtocol
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationProtocolsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/application-protocols/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationProtocolRequest == nil {
		return localVarReturnValue, nil, reportError("applicationProtocolRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationProtocolRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationsBulkDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationRequest *[]ApplicationRequest
}

func (r ApiPluginsApplicationsApplicationsBulkDestroyRequest) ApplicationRequest(applicationRequest []ApplicationRequest) ApiPluginsApplicationsApplicationsBulkDestroyRequest {
	r.applicationRequest = &applicationRequest
	return r
}

func (r ApiPluginsApplicationsApplicationsBulkDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationsBulkDestroyExecute(r)
}

/*
PluginsApplicationsApplicationsBulkDestroy Method for PluginsApplicationsApplicationsBulkDestroy

Delete a list of application objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationsBulkDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationsBulkDestroy(ctx context.Context) ApiPluginsApplicationsApplicationsBulkDestroyRequest {
	return ApiPluginsApplicationsApplicationsBulkDestroyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationsBulkDestroyExecute(r ApiPluginsApplicationsApplicationsBulkDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationsBulkDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/applications/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationRequest == nil {
		return nil, reportError("applicationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationsBulkPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationRequest *[]ApplicationRequest
}

func (r ApiPluginsApplicationsApplicationsBulkPartialUpdateRequest) ApplicationRequest(applicationRequest []ApplicationRequest) ApiPluginsApplicationsApplicationsBulkPartialUpdateRequest {
	r.applicationRequest = &applicationRequest
	return r
}

func (r ApiPluginsApplicationsApplicationsBulkPartialUpdateRequest) Execute() ([]Application, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationsBulkPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationsBulkPartialUpdate Method for PluginsApplicationsApplicationsBulkPartialUpdate

Patch a list of application objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationsBulkPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationsBulkPartialUpdate(ctx context.Context) ApiPluginsApplicationsApplicationsBulkPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationsBulkPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Application
func (a *PluginsAPIService) PluginsApplicationsApplicationsBulkPartialUpdateExecute(r ApiPluginsApplicationsApplicationsBulkPartialUpdateRequest) ([]Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationsBulkPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/applications/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationRequest == nil {
		return localVarReturnValue, nil, reportError("applicationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationsBulkUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationRequest *[]ApplicationRequest
}

func (r ApiPluginsApplicationsApplicationsBulkUpdateRequest) ApplicationRequest(applicationRequest []ApplicationRequest) ApiPluginsApplicationsApplicationsBulkUpdateRequest {
	r.applicationRequest = &applicationRequest
	return r
}

func (r ApiPluginsApplicationsApplicationsBulkUpdateRequest) Execute() ([]Application, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationsBulkUpdateExecute(r)
}

/*
PluginsApplicationsApplicationsBulkUpdate Method for PluginsApplicationsApplicationsBulkUpdate

Put a list of application objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationsBulkUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationsBulkUpdate(ctx context.Context) ApiPluginsApplicationsApplicationsBulkUpdateRequest {
	return ApiPluginsApplicationsApplicationsBulkUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Application
func (a *PluginsAPIService) PluginsApplicationsApplicationsBulkUpdateExecute(r ApiPluginsApplicationsApplicationsBulkUpdateRequest) ([]Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationsBulkUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/applications/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationRequest == nil {
		return localVarReturnValue, nil, reportError("applicationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationsCreateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	applicationRequest *ApplicationRequest
}

func (r ApiPluginsApplicationsApplicationsCreateRequest) ApplicationRequest(applicationRequest ApplicationRequest) ApiPluginsApplicationsApplicationsCreateRequest {
	r.applicationRequest = &applicationRequest
	return r
}

func (r ApiPluginsApplicationsApplicationsCreateRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationsCreateExecute(r)
}

/*
PluginsApplicationsApplicationsCreate Method for PluginsApplicationsApplicationsCreate

Post a list of application objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationsCreateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationsCreate(ctx context.Context) ApiPluginsApplicationsApplicationsCreateRequest {
	return ApiPluginsApplicationsApplicationsCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Application
func (a *PluginsAPIService) PluginsApplicationsApplicationsCreateExecute(r ApiPluginsApplicationsApplicationsCreateRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/applications/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationRequest == nil {
		return localVarReturnValue, nil, reportError("applicationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationsDestroyRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationsDestroyExecute(r)
}

/*
PluginsApplicationsApplicationsDestroy Method for PluginsApplicationsApplicationsDestroy

Delete a application object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application.
 @return ApiPluginsApplicationsApplicationsDestroyRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationsDestroy(ctx context.Context, id int32) ApiPluginsApplicationsApplicationsDestroyRequest {
	return ApiPluginsApplicationsApplicationsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PluginsAPIService) PluginsApplicationsApplicationsDestroyExecute(r ApiPluginsApplicationsApplicationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/applications/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationsListRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	limit *int32
	offset *int32
	ordering *string
}

// Number of results to return per page.
func (r ApiPluginsApplicationsApplicationsListRequest) Limit(limit int32) ApiPluginsApplicationsApplicationsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPluginsApplicationsApplicationsListRequest) Offset(offset int32) ApiPluginsApplicationsApplicationsListRequest {
	r.offset = &offset
	return r
}

// Which field to use when ordering the results.
func (r ApiPluginsApplicationsApplicationsListRequest) Ordering(ordering string) ApiPluginsApplicationsApplicationsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiPluginsApplicationsApplicationsListRequest) Execute() (*PaginatedApplicationList, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationsListExecute(r)
}

/*
PluginsApplicationsApplicationsList Method for PluginsApplicationsApplicationsList

Get a list of application objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPluginsApplicationsApplicationsListRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationsList(ctx context.Context) ApiPluginsApplicationsApplicationsListRequest {
	return ApiPluginsApplicationsApplicationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedApplicationList
func (a *PluginsAPIService) PluginsApplicationsApplicationsListExecute(r ApiPluginsApplicationsApplicationsListRequest) (*PaginatedApplicationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedApplicationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/applications/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	patchedApplicationRequest *PatchedApplicationRequest
}

func (r ApiPluginsApplicationsApplicationsPartialUpdateRequest) PatchedApplicationRequest(patchedApplicationRequest PatchedApplicationRequest) ApiPluginsApplicationsApplicationsPartialUpdateRequest {
	r.patchedApplicationRequest = &patchedApplicationRequest
	return r
}

func (r ApiPluginsApplicationsApplicationsPartialUpdateRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationsPartialUpdateExecute(r)
}

/*
PluginsApplicationsApplicationsPartialUpdate Method for PluginsApplicationsApplicationsPartialUpdate

Patch a application object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application.
 @return ApiPluginsApplicationsApplicationsPartialUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationsPartialUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationsPartialUpdateRequest {
	return ApiPluginsApplicationsApplicationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Application
func (a *PluginsAPIService) PluginsApplicationsApplicationsPartialUpdateExecute(r ApiPluginsApplicationsApplicationsPartialUpdateRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/applications/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedApplicationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationsRetrieveRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
}

func (r ApiPluginsApplicationsApplicationsRetrieveRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationsRetrieveExecute(r)
}

/*
PluginsApplicationsApplicationsRetrieve Method for PluginsApplicationsApplicationsRetrieve

Get a application object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application.
 @return ApiPluginsApplicationsApplicationsRetrieveRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationsRetrieve(ctx context.Context, id int32) ApiPluginsApplicationsApplicationsRetrieveRequest {
	return ApiPluginsApplicationsApplicationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Application
func (a *PluginsAPIService) PluginsApplicationsApplicationsRetrieveExecute(r ApiPluginsApplicationsApplicationsRetrieveRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/applications/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPluginsApplicationsApplicationsUpdateRequest struct {
	ctx context.Context
	ApiService *PluginsAPIService
	id int32
	applicationRequest *ApplicationRequest
}

func (r ApiPluginsApplicationsApplicationsUpdateRequest) ApplicationRequest(applicationRequest ApplicationRequest) ApiPluginsApplicationsApplicationsUpdateRequest {
	r.applicationRequest = &applicationRequest
	return r
}

func (r ApiPluginsApplicationsApplicationsUpdateRequest) Execute() (*Application, *http.Response, error) {
	return r.ApiService.PluginsApplicationsApplicationsUpdateExecute(r)
}

/*
PluginsApplicationsApplicationsUpdate Method for PluginsApplicationsApplicationsUpdate

Put a application object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this application.
 @return ApiPluginsApplicationsApplicationsUpdateRequest
*/
func (a *PluginsAPIService) PluginsApplicationsApplicationsUpdate(ctx context.Context, id int32) ApiPluginsApplicationsApplicationsUpdateRequest {
	return ApiPluginsApplicationsApplicationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Application
func (a *PluginsAPIService) PluginsApplicationsApplicationsUpdateExecute(r ApiPluginsApplicationsApplicationsUpdateRequest) (*Application, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PluginsAPIService.PluginsApplicationsApplicationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/plugins/applications/applications/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applicationRequest == nil {
		return localVarReturnValue, nil, reportError("applicationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applicationRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
